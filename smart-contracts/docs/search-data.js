window.Aiken.initSearch([{"doc":"utils","title":"get_protocol_from_inputs_ref","content":"get_protocol_from_inputs_ref(\n  transaction: Transaction,\n  protocol_policy_id: PolicyId,\n  protocol_id_tn: ByteArray,\n  expect_count: Int,\n) -&gt; Option&lt;(Output, ProtocolDatum)&gt;\n Get protocol datum from reference inputs\n Returns an Option containing the protocol output and datum if found\n \n # Arguments\n * transaction - The transaction being validated\n * protocol_policy_id - The policy ID of the protocol token\n * protocol_id_tn - The token name of the protocol ID token\n * expect_count - Expected number of protocol inputs (usually 1)","url":"utils.html#get_protocol_from_inputs_ref"},{"doc":"utils","title":"get_protocol_from_inputs","content":"get_protocol_from_inputs(\n  transaction: Transaction,\n  protocol_policy_id: PolicyId,\n  protocol_id_tn: ByteArray,\n  expect_count: Int,\n) -&gt; Option&lt;(Output, ProtocolDatum)&gt;\n Get protocol datum from inputs\n Returns an Option containing the protocol output and datum if found\n \n # Arguments\n * transaction - The transaction being validated\n * protocol_policy_id - The policy ID of the protocol token\n * protocol_id_tn - The token name of the protocol ID token\n * expect_count - Expected number of protocol inputs (usually 1)","url":"utils.html#get_protocol_from_inputs"},{"doc":"utils","title":"get_protocol_from_outputs","content":"get_protocol_from_outputs(\n  transaction: Transaction,\n  protocol_policy_id: PolicyId,\n  protocol_id_tn: ByteArray,\n  expect_count: Int,\n) -&gt; Option&lt;(Output, ProtocolDatum)&gt;\n Get protocol datum from outputs\n Returns an Option containing the protocol output and datum if found\n \n # Arguments\n * transaction - The transaction being validated\n * protocol_policy_id - The policy ID of the protocol token\n * protocol_id_tn - The token name of the protocol ID token\n * expect_count - Expected number of protocol outputs (usually 1)","url":"utils.html#get_protocol_from_outputs"},{"doc":"utils","title":"get_otc_from_inputs","content":"get_otc_from_inputs(\n  transaction: Transaction,\n  otc_policy_id: PolicyId,\n  otc_id_tn: ByteArray,\n  expect_count: Int,\n) -&gt; Option&lt;(Output, OTCDatum)&gt;\n Get OTC output and datum from inputs\n Returns an Option containing the OTC output and datum if found\n \n # Arguments\n * transaction - The transaction being validated\n * otc_policy_id - The policy ID of the OTC token\n * otc_id_tn - The token name of the OTC ID token\n * expect_count - Expected number of OTC inputs (usually 1)","url":"utils.html#get_otc_from_inputs"},{"doc":"utils","title":"get_otc_with_outref_from_inputs","content":"get_otc_with_outref_from_inputs(\n  transaction: Transaction,\n  otc_policy_id: PolicyId,\n  otc_id_tn: ByteArray,\n  expect_count: Int,\n) -&gt; Option&lt;(Input, OTCDatum)&gt;\n Get OTC input with output reference and datum from inputs\n Returns an Option containing the input and OTC datum if found\n \n # Arguments\n * transaction - The transaction being validated\n * otc_policy_id - The policy ID of the OTC token\n * otc_id_tn - The token name of the OTC ID token\n * expect_count - Expected number of OTC inputs (usually 1)","url":"utils.html#get_otc_with_outref_from_inputs"},{"doc":"utils","title":"get_otc_from_outputs","content":"get_otc_from_outputs(\n  transaction: Transaction,\n  otc_policy_id: PolicyId,\n  otc_id_tn: ByteArray,\n  expect_count: Int,\n) -&gt; Option&lt;(Output, OTCDatum)&gt;\n Get OTC output and datum from outputs\n Returns an Option containing the OTC output and datum if found\n \n # Arguments\n * transaction - The transaction being validated\n * otc_policy_id - The policy ID of the OTC token\n * otc_id_tn - The token name of the OTC ID token\n * expect_count - Expected number of OTC outputs (usually 1)","url":"utils.html#get_otc_from_outputs"},{"doc":"utils","title":"check_if_otc_nft_is_present_in_inputs","content":"check_if_otc_nft_is_present_in_inputs(\n  transaction: Transaction,\n  otc_policy_id: PolicyId,\n  otc_nft_tn: ByteArray,\n) -&gt; Bool\n Check if OTC NFT token is present in transaction inputs\n Returns true if at least one input contains the OTC NFT\n \n # Arguments\n * transaction - The transaction being validated\n * otc_policy_id - The policy ID of the OTC NFT\n * otc_nft_tn - The token name of the OTC NFT","url":"utils.html#check_if_otc_nft_is_present_in_inputs"},{"doc":"utils","title":"extract_protocol_datum","content":"extract_protocol_datum(output: Output) -&gt; Option&lt;ProtocolDatum&gt;\n Extract protocol datum from an output\n Returns an Option containing the protocol datum if successfully extracted\n \n # Arguments\n * output - The output containing the datum","url":"utils.html#extract_protocol_datum"},{"doc":"utils","title":"extract_otc_datum","content":"extract_otc_datum(output: Output) -&gt; Option&lt;OTCDatum&gt;\n Extract OTC datum from an output\n Returns an Option containing the OTC datum if successfully extracted\n \n # Arguments\n * output - The output containing the datum","url":"utils.html#extract_otc_datum"},{"doc":"utils","title":"is_admin_auth","content":"is_admin_auth(transaction: Transaction, protocolDatum: ProtocolDatum) -&gt; Bool\n Check if transaction is authorized by a protocol admin\n Returns true if signed by an admin or contains admin token\n \n # Arguments\n * transaction - The transaction being validated\n * protocolDatum - The protocol datum containing admin information","url":"utils.html#is_admin_auth"},{"doc":"utils","title":"validate_protocol_params","content":"validate_protocol_params(protocolDatum: ProtocolDatum) -&gt; Bool\n Validate protocol parameters\n Returns true if all parameters are valid:\n - Minimum ADA is positive\n - Admin list is not empty\n - MAYZ deposit requirement is positive\n - Admin token policy ID is not empty\n\n # Arguments\n * protocolDatum - The protocol datum to validate","url":"utils.html#validate_protocol_params"},{"doc":"utils","title":"is_signed_by_creator","content":"is_signed_by_creator(\n  transaction: Transaction,\n  creator: VerificationKeyHash,\n) -&gt; Bool\n Check if transaction is signed by OTC creator\n Returns true if the creator&#39;s verification key hash is among the signers\n \n # Arguments\n * transaction - The transaction being validated\n * creator - The verification key hash of the OTC creator","url":"utils.html#is_signed_by_creator"},{"doc":"utils","title":"add_lovelace","content":"add_lovelace(v: Value, lovelace: Int) -&gt; Value\n Add lovelace to a value\n Returns a new value with the added lovelace amount\n \n # Arguments\n * v - The base value\n * lovelace - The amount of lovelace to add","url":"utils.html#add_lovelace"},{"doc":"utils","title":"check_value_sent_to_wallet","content":"check_value_sent_to_wallet(\n  transaction: Transaction,\n  wallet: VerificationKeyHash,\n  value: Value,\n) -&gt; Bool\n Check if a value is sent to a specific wallet address\n Returns true if the wallet receives at least the specified value\n \n # Arguments\n * transaction - The transaction being validated\n * wallet - The verification key hash of the recipient wallet\n * value - The minimum value that should be received","url":"utils.html#check_value_sent_to_wallet"},{"doc":"utils","title":"check_value_sent_to_signer","content":"check_value_sent_to_signer(transaction: Transaction, value: Value) -&gt; Bool\n Check if a value is sent to the transaction signer\n Returns true if the signer receives at least the specified value\n \n # Arguments\n * transaction - The transaction being validated\n * value - The minimum value that should be received","url":"utils.html#check_value_sent_to_signer"},{"doc":"utils","title":"validate_otc_name","content":"validate_otc_name(\n  name: ByteArray,\n  token_tn: ByteArray,\n  token_amount: Int,\n) -&gt; Bool\n Validate OTC token name format\n Returns true if the name follows the convention &quot;OTC-[TOKEN]-[AMOUNT]&quot;\n \n # Arguments\n * name - The OTC token name to validate\n * token_tn - The underlying token name\n * token_amount - The amount of underlying tokens","url":"utils.html#validate_otc_name"},{"doc":"utils","title":"generate_otc_name","content":"generate_otc_name(token_tn: ByteArray, amount: Int) -&gt; ByteArray\n Generate OTC token name following the convention &quot;OTC-[TOKEN]-[AMOUNT]&quot;\n \n # Arguments\n * token_tn - The underlying token name\n * amount - The amount of underlying tokens","url":"utils.html#generate_otc_name"},{"doc":"utils","title":"extract_otc_redeemer","content":"extract_otc_redeemer(redeemer: Redeemer) -&gt; Option&lt;OTCRedeemer&gt;\n","url":"utils.html#extract_otc_redeemer"},{"doc":"utils","title":"is_close_or_cancel","content":"is_close_or_cancel(redeemers: List&lt;Redeemer&gt;) -&gt; Bool\n Check if any redeemer in the transaction is a Close or Cancel operation","url":"utils.html#is_close_or_cancel"},{"doc":"utils","title":"get_redeemer_of","content":"get_redeemer_of(\n  redeemers: Pairs&lt;ScriptPurpose, Redeemer&gt;,\n  outRef: OutputReference,\n) -&gt; List&lt;Redeemer&gt;\n Get redeemer for a specific output reference","url":"utils.html#get_redeemer_of"},{"doc":"utils","title":"utils","content":"","url":"utils.html"},{"doc":"types","title":"NFTRedeemer","content":"NFTRedeemer {\n  MintNFT\n  BurnNFT\n}\n Redeemers for the OTC NFT Minting Policy\nMintNFT\n Mint new OTC NFT token during position creation\nBurnNFT\n Burn OTC NFT token during Close/Cancel","url":"types.html#NFTRedeemer"},{"doc":"types","title":"OTCDatum","content":"OTCDatum {\n  od_creator: VerificationKeyHash,\n  od_token_policy_id: PolicyId,\n  od_token_tn: ByteArray,\n  od_token_amount: Int,\n  od_otc_nft_policy_id: PolicyId,\n  od_otc_nft_tn: ByteArray,\n  od_mayz_policy_id: PolicyId,\n  od_mayz_tn: ByteArray,\n  od_mayz_locked: Int,\n  od_min_ada: Int,\n}\n Datum for OTC positions storing state and configuration\nOTCDatum {\n  od_creator: VerificationKeyHash,\n  od_token_policy_id: PolicyId,\n  od_token_tn: ByteArray,\n  od_token_amount: Int,\n  od_otc_nft_policy_id: PolicyId,\n  od_otc_nft_tn: ByteArray,\n  od_mayz_policy_id: PolicyId,\n  od_mayz_tn: ByteArray,\n  od_mayz_locked: Int,\n  od_min_ada: Int,\n}\n","url":"types.html#OTCDatum"},{"doc":"types","title":"OTCNFTParams","content":"OTCNFTParams {\n  pp_otc_nft_policy_id_tx_out_ref: OutputReference,\n  pp_otc_validator_hash: ScriptHash,\n  pp_protocol_policy_id: PolicyId,\n  pp_protocol_id_tn: ByteArray,\n  pp_otc_id_tn: ByteArray,\n}\n Parameters for the OTC NFT Minting Policy \nOTCNFTParams {\n  pp_otc_nft_policy_id_tx_out_ref: OutputReference,\n  pp_otc_validator_hash: ScriptHash,\n  pp_protocol_policy_id: PolicyId,\n  pp_protocol_id_tn: ByteArray,\n  pp_otc_id_tn: ByteArray,\n}\n","url":"types.html#OTCNFTParams"},{"doc":"types","title":"OTCParams","content":"OTCParams {\n  pp_protocol_policy_id: PolicyId,\n  pp_protocol_id_tn: ByteArray,\n  pp_otc_id_tn: ByteArray,\n}\n OTC Contract Related Types\nOTCParams {\n  pp_protocol_policy_id: PolicyId,\n  pp_protocol_id_tn: ByteArray,\n  pp_otc_id_tn: ByteArray,\n}\n","url":"types.html#OTCParams"},{"doc":"types","title":"OTCRedeemer","content":"OTCRedeemer {\n  CreateOTC\n  ClaimOTC\n  CloseOTC\n  CancelOTC\n  UpdateOTCMinADA { new_min_ada: Int }\n}\n Redeemers for the OTC Contract\nCreateOTC\n Create new OTC position and mint OTC ID token\nClaimOTC\n Claim underlying tokens using OTC NFT\nCloseOTC\n Close completed position and retrieve MAYZ deposit\nCancelOTC\n Cancel active position and retrieve all assets\nUpdateOTCMinADA { new_min_ada: Int }\n Update minimum ADA requirement for OTC UTXO","url":"types.html#OTCRedeemer"},{"doc":"types","title":"ProtocolDatum","content":"ProtocolDatum {\n  pd_admins: List&lt;VerificationKeyHash&gt;,\n  pd_token_admin_policy_id: PolicyId,\n  pd_mayz_policy_id: PolicyId,\n  pd_mayz_tn: ByteArray,\n  pd_mayz_deposit_requirement: Int,\n  pd_min_ada: Int,\n}\n Protocol Datum storing governance and configuration parameters\nProtocolDatum {\n  pd_admins: List&lt;VerificationKeyHash&gt;,\n  pd_token_admin_policy_id: PolicyId,\n  pd_mayz_policy_id: PolicyId,\n  pd_mayz_tn: ByteArray,\n  pd_mayz_deposit_requirement: Int,\n  pd_min_ada: Int,\n}\n","url":"types.html#ProtocolDatum"},{"doc":"types","title":"ProtocolParams","content":"ProtocolParams {\n  pp_protocol_policy_id_tx_out_ref: OutputReference,\n  pp_protocol_id_tn: ByteArray,\n}\n Parameters for the Protocol Contract and its Policy ID minting\nProtocolParams {\n  pp_protocol_policy_id_tx_out_ref: OutputReference,\n  pp_protocol_id_tn: ByteArray,\n}\n","url":"types.html#ProtocolParams"},{"doc":"types","title":"ProtocolRedeemer","content":"ProtocolRedeemer {\n  CreateProtocol\n  UpdateProtocolParams\n  UpdateProtocolMinADA { new_min_ada: Int }\n}\n Redeemers for the Protocol Contract\nCreateProtocol\n Initialize protocol by minting Protocol ID token\nUpdateProtocolParams\n Update protocol parameters while maintaining Protocol ID token\nUpdateProtocolMinADA { new_min_ada: Int }\n Update minimum ADA requirement for protocol UTXOs","url":"types.html#ProtocolRedeemer"},{"doc":"types","title":"types","content":" Redeemers for the Protocol Contract","url":"types.html"}]);